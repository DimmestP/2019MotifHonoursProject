---
title: "abhi_scRNA_v2_glmnet"
author: "Abhishek Jain"
date: "10th April 2019"
output: 
  md_document:
    variant: markdown_github
editor_options:
  chunk_output_type: console
---

## Updates 10/04/19:

  1. Replaced names of motifs from regex format to IUPAC alphabet
  2. Fixed motifs_matrix using strtoi for proper 0 and 1 representation
  3. Added chunk for creating GeneLists for GO analysis 
  
## Objectives: 

  1. Repeat CV calculation like before
  2. Import and use a motifs list to generate motifs table (Using Regex)
  3. Use glmnet for penalised regression analysis of effect on CV^2
  4. Compile list of genes for each glmnet motif for GO Term Analysis
  
## Initation:

```{R Setup}
library(tidyverse)
library(ggplot2)
library(glmnet)
```



```{R Load Data}
#Error Handling for File not found
#Syntax tryCatch( {Exprns}, error = function(any){ print("out") } )
tryCatch({
            UTR_raw <- read_rds("data/Sun_mutation_UTRs.rds")
            sc_raw <-read_tsv("data/YPD_scRNA.tab")
            motifs_raw <- scan("data/list_motifs.txt", character())
          },
        error = function(x) 
          { 
            print(x) #print actual error
            cat("\nCurrent directory:",
                getwd())  
          }
)

#Get sequences from UTR_raw in a separate vector
UTR_3 <- UTR_raw$UTR3_seq


  
```

Then, create a tibble with motifs for every gene:
Note: Raw data already had motif counts but were combined for 3' and 5' UTRs and are not individual.

```{R Freq of Motifs}

motifs <- motifs_raw %>% str_replace_all(c("W" = "(A|T)", "S" = "(C|G)", "M" = "(A|C)", "K" = "(G|T)", "R" = "(A|G)", "Y" = "(C|T)", "B" = "(C|G|T)", "D" = "(A|G|T)", "H" = "(A|C|T)", "V" = "(A|C|G)", "N" = "(A|C|G|T)"))

#Initate ref tibble and store gene names
ref_motifs <- tibble(geneName = UTR_raw$genename)


#Search and add frequency of each c(motif) as a column in ref dataset
for (i in 1:length(motifs)){
ref_motifs <- mutate(.data = ref_motifs, 
                      !!motifs_raw[i] := str_count(UTR_3, motifs[i]))
}


```


Calculate various cell to cell variation estimates; 

  Note: previous version used linear model for each measure and showed best performance for log(CV^2)

```{R Calculate CV}

#new dataframe with cell to cell differences from sc_raw data
sc_summ_various <- sc_raw %>%
  select(-comGeneName)%>%
  gather(key = "cell", value = "transcripts", select = -geneName)%>%
    group_by(geneName)%>%
      #add columns with different measures of variation
      summarize(mean_t = mean(transcripts), 
             stdev_t = sd(transcripts),
             variance_t = var(transcripts))%>%
      filter(mean_t > 0)%>%
      mutate(VMR_t = variance_t/mean_t,
             CV_t = stdev_t/mean_t,
             CV2_t = (CV_t^2))

sc_summ <- sc_summ_various %>%
  select(geneName, CV2_t)
```

```{R Shrink and add rates}
#add coefficient of variation
ref_motifs_t <- left_join(ref_motifs, sc_summ, by = "geneName")%>%
  filter(is.finite(CV2_t))

```

```{R Setup Data for regression}
#motifs = c("TGTAAATA", "TGCAT", "TTTTTTA", "ATATTC")

model_data <- ref_motifs_t %>%
  #convert motif frequencies to presence and then to factor
  mutate_at(motifs_raw, funs(replace(., .>= 1, 1)))%>%
  mutate_at(motifs_raw, funs(factor(.) ))%>%
  mutate(log_CV2_t = log(CV2_t))%>%
  select(-CV2_t)
        

```

Following section performs lasso regression using glmnet. First, a model matrix is created for variables (motifs), then a glmnet is performed on response (log_CV2_t) yielding a tibble from cross validated glmnet containing each motif's coefficient. 

Then motifs are filtered for non-zero coefficients.

```{R Penalised regression}

motifs_matrix <- model_data %>%
  select(-geneName, -log_CV2_t) %>%
  sapply(., strtoi)%>%
  data.matrix()

  motifs_glm <- glmnet(motifs_matrix, y = model_data$log_CV2_t)
plot(motifs_glm, xvar="lambda")

#Cross Validated Glmnet to get lambda.min for extracting coeffs 
motifs_cv_glm <- cv.glmnet(x = motifs_matrix, y = model_data$log_CV2_t)
plot(motifs_cv_glm)

coefs <- data.matrix(coef(motifs_cv_glm, s = "lambda.min"))
#Create a tibble of coefficients ordered by absolute value
sig_glms <- tibble(
      motif_glmnet = rownames(coefs)[coefs != 0],
      coeff_glmnet = coefs[coefs != 0]
    ) %>%
        arrange(desc(abs(coeff_glmnet)))


```


Then create a list of genes containing these motifs, (list of vectors) and then manually performed Gene Ontology on each list
  See: "/data/motifs_fun" for GO results

```{R List Genes with motifs}
genes_present_l <- list()
#using index -1 for first intercept row #intercept isn't first
for (each_m in filter(.data = sig_glms, motif_glmnet != "(Intercept)")$motif_glmnet)
  {
  #add all geneName values with 1 for each motif to a list of vectors
  genes_present_l[[each_m]] <- filter(.data = model_data, 
                           !!as.name(each_m) == 1)$geneName

  write(x = genes_present_l[[each_m]], 
        file = paste0("data/motifs_fun/", each_m, ".txt"))
  }

#cleanup
remove(each_m)

```

```{R Test2}


```


```{R Test2, eval=FALSE, include=FALSE}


```