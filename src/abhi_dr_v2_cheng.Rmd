---
title: "Abhi Motif Analaysis from Cheng et al 2017 v2"
author: "Abhishek Jain"
date: "1st March 2019"
output: 
  md_document:
    variant: markdown_github
editor_options:
  chunk_output_type: console
---

## Objectives: 

  1. To create a script that calculates frequency of four specific motifs in yeast 3'UTR of all yeast gene (for each ORF)

  2. Find synthesis and degradation rates of each gene from Sun et al. data and add it to motif frequency table for further analysis
  

Method:
First, use cheng et al dataset (and previous dataframe codes) to create a table with wild type gene synthesis and decay rates

## Initation:

```{R Setup}
library(tidyverse)
library(ggplot2)
```



Update: Use the UTR dataset in Cheng et al. i.e. from Sun et al. 2013


```{R Load Data}
#Error Handling for File not found
#Syntax tryCatch( {Exprns}, error = function(any){ print("out") } )
tryCatch({
            UTR_raw <- read_rds("data/Sun_mutation_UTRs.rds")
            dr_raw <- read_tsv("data/sun_total_dr.txt", locale = locale(decimal = ","))
            motifs_raw <- scan("data/list_motifs.txt", character())
            #sr_raw <- read_table("data/sun_total_sr.txt")
          },
        error = function(x) 
          { 
            print(x) #print actual error
            cat("\nCurrent directory:",
                getwd())  
          }
)

UTR_3 <- UTR_raw$UTR3_seq

#change weird name of third column of wt degradation rate
colnames(dr_raw)[3] <- "d_rate"

#new smaller dataframe with first three cols
dr_data <- dr_raw %>% 
  dplyr::select(orf, d_rate) %>%
    mutate(hlife = log(2)/d_rate) %>%
      select(-d_rate)
    
  
```

Then, create a tibble with motifs for every gene:
Note: This data already has motif counts but those are combined for 3' and 5' UTRs and are not individual.

```{R Freq of Motifs}


#new dataframe with ORF names, and frequency counts of some motifs  
ref_motifs <- tibble(orf = UTR_raw$genename, ATATTC = str_count(UTR_3, "ATATTC"), TGCAT = str_count(UTR_3, "TGCAT"), TGTAAATA = str_count(UTR_3, "TGTAAATA"), TTTTTTA = str_count(UTR_3, "TTTTTTA"))


```



```{R Shrink and add rates}
#create a dataset with decayrate(dr) by matching orf name to dr dataframe
ref_motifs_rates <- ref_motifs %>%
    mutate(hlife = dr_data$hlife[match(orf, dr_data$orf)])

```


Follwoing Boxplots are replication of Figure 4A in Cheng et al. 2017. 

```{R Boxplots}
par(mfrow = c(2,2))
#Convert frequency of motif into a >= limit

plot_ATATTC <- ref_motifs_rates %>% mutate(ATATTC = replace(ATATTC, ATATTC >= 2, 2)) %>%
ggplot(., aes(x = ATATTC, y = hlife)) +
  geom_boxplot(aes(group = ATATTC)) + 
  scale_x_continuous(breaks = c(0,1,2), labels = c("0", "1", ">=2")) +
  scale_y_continuous(trans = "log10", breaks = c(1,5,10,20,40,150))




plot_TGCAT <- ref_motifs_rates %>% mutate(TGCAT = replace(TGCAT, TGCAT >= 3, 3)) %>%
ggplot(data = ., 
       aes(x = TGCAT, y = hlife)) +
  geom_boxplot(aes(group = TGCAT)) + 
  scale_x_continuous(breaks = c(0,1,2,3), labels = c("0", "1", "2", ">=3"))+
  scale_y_continuous(trans = "log10", breaks = c(1,5,10,20,40,150))

plot_TGTAAATA <- ref_motifs_rates %>% mutate(TGTAAATA = replace(TGTAAATA, TGTAAATA >= 1, 1)) %>%
ggplot(data = ., 
       aes(x = TGTAAATA, y = hlife)) +
  geom_boxplot(aes(group = TGTAAATA)) + 
  scale_x_continuous(breaks = c(0,1), labels = c("0", ">=1"))+
  scale_y_continuous(trans = "log10", breaks = c(1,5,10,20,40,150))


plot_TTTTTTA <- ref_motifs_rates %>% mutate(TTTTTTA = replace(TTTTTTA, TTTTTTA >= 2, 2)) %>%
ggplot(data = ., 
       aes(x = TTTTTTA, y = hlife)) +
  geom_boxplot(aes(group = TTTTTTA)) + 
  scale_x_continuous(breaks = c(0,1,2), labels = c("0", "1", ">=2"))+
  scale_y_continuous(trans = "log10", breaks = c(1,5,10,20,40,150))

gridExtra::grid.arrange(plot_ATATTC, plot_TGCAT, plot_TGTAAATA, plot_TTTTTTA, ncol=4)

```

##Linear Modeling


```{R Setup Data for regression}
motifs = c("TGTAAATA", "TGCAT", "TTTTTTA", "ATATTC")


model_data <- ref_motifs_rates %>%
  #remove rows with NAs
  filter(!is.na(hlife))%>%
    #convert motif frequencies to presence and then to factor
    mutate_at(motifs, funs(replace(., .>= 1, 1)))%>%
    mutate_at(motifs, funs(factor(.) ))%>%
      #add a column with log transformed hlife
      mutate(log2_hlife = log2(hlife))
        

```



```{R Create Models}

#to create separate linear model for each motif
each_model <- model_data %>%
  gather("motif", "presence", ATATTC, TGTAAATA, TGCAT, TTTTTTA)%>%
    group_by(motif)%>%
      #create an lm for each motif - will be stored as a tibble
      do(each_lm = lm(log2_hlife ~ presence, data = .))%>%
    ungroup()

#to create a multiple linear model
all_lm <- lm(data =model_data, log2_hlife ~ ATATTC + TGTAAATA + TGCAT + TTTTTTA)

#use multiple LM to compute predicted hlife
#NOTE: exp2 for anti log of log2(hlife)
model_data_pred <- add_column(model_data, 
                           pred_hlife = 2 ^ predict.lm(all_lm, model_data))



```

n.b. in the following plot, X and Y axis are NOT logfold

```{R Plot Predicted Linear Model}
mean_hlife <- mean(model_data_pred$hlife)
model_data_pred %>% ggplot(data = ., aes(x = pred_hlife, y = hlife)) + 
  geom_point() + 
  geom_smooth(method = "lm", formula = y ~ x) +
  scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") + labs(y = "Half Life", x = "Predicted Half Life") + geom_hline(aes(yintercept = mean(hlife)), col = "red") + geom_text(aes(x = 8, y = mean_hlife, label = paste("mean = ", round(mean_hlife, digits = 4))), vjust = -10, col = "red") 
        
```

##Cross Validation of Linear Models

In this section, cross validation of linear model is performed by removing a group and then performing modelling on the rest of the groups. 

```{R Groupwise Linear Models}


model_data_groups <- model_data
#Create Randomly Sampled  Groups 1-10
model_data_groups$groupID <- sample(1:10, size = nrow(model_data_groups), replace = TRUE) 

#initialize a blank list
#initialize a tibble for storing lms and coefficients
group_lms <- tibble(group_excl = 1:10, lm = vector(mode = "list", length = 10), coeffs = vector(mode = "list", length = 10))

##Create Cross Validated Linear Models 

par(mfrow = c(2,5))

for(i in 1:10){
  group_lms[[2]][[i]] <- model_data_groups %>%
    #Exclude group i from data and create lm
    filter(groupID != i)%>%
    lm(log2_hlife ~ ATATTC + TGTAAATA + TGCAT + TTTTTTA, data = .)
  
  #calculate and store coeffs of each lm in coeff column
  group_lms[[3]][[i]] <- summary(group_lms[[2]][[i]])$coefficient
  

  plot(group_lms$lm[[i]], which = 2, col= 2, main = paste("Excl. Group", i,  collapse = ""))

}
# ^: END OF FOR LOOP ^

#print all coeffs
group_lms$coeffs


```

## Questions: 

1. Best way to enable values (median?) to show up on the boxplot

2. What parameters should be compared in groupwise lms; what would be the best way to visualize these together?

 

JFF: Create multiple boxplots with slightly different parameters?



```{R For glmnet}

motifs_big <- motifs_raw %>% str_replace_all(c("U" = "T", "W" = "(A|T)", "S" = "(C|G)", "M" = "(A|C)", "K" = "(G|T)", "R" = "(A|G)", "Y" = "(C|T)", "B" = "(C|G|T)", "D" = "(A|G|T)", "H" = "(A|C|T)", "V" = "(A|C|G)", "N" = "(A|C|G|T)"))

#Initate ref tibble and store gene names
ref_motifs_big <- tibble(orf = UTR_raw$genename)


#Search and add frequency of each c(motif) as a column in ref dataset
for (i in 1:length(motifs_big)){
ref_motifs_big <- mutate(.data = ref_motifs_big, 
                      !!motifs_raw[i] := str_count(UTR_3, motifs_big[i]))
}



#combine ref motifs with hlife data 
ref_motifs_big_t <- left_join(ref_motifs_big, dr_data, by = "orf")%>%
  filter(is.finite(hlife))


#motifs = c("TGTAAATA", "TGCAT", "TTTTTTA", "ATATTC")

model_data_big <- ref_motifs_big_t %>%
  #convert motif frequencies to presence and then to factor
  mutate_at(motifs_raw, funs(replace(., .>= 1, 1)))%>%
  mutate_at(motifs_raw, funs(factor(.) ))%>%
  mutate(log2_hlife = log2(hlife))%>%
  select(-hlife)
        

```

```{R hlife glmnet}
library(glmnet)
motifs_matrix <- model_data_big %>%
    dplyr::select(-orf, -log2_hlife) %>%
      sapply(., strtoi)%>%
        data.matrix()

motifs_glm <- glmnet(motifs_matrix, y = model_data_big$log2_hlife)

#Cross Validated Glmnet to get lambda.min for extracting coeffs 
motifs_cv_glm <- cv.glmnet(x = motifs_matrix, y = model_data_big$log2_hlife)
plot(motifs_cv_glm)

coefs <- data.matrix(coef(motifs_cv_glm, s = "lambda.min"))
#Create a tibble of coefficients ordered by absolute value
sig_glms <- tibble(
      motif_glmnet = rownames(coefs)[coefs != 0],
      coeff_glmnet = coefs[coefs != 0]
    ) %>%
        arrange(desc(abs(coeff_glmnet)))

```

```{R New glmnet, eval=FALSE, include=FALSE}
motifs_matrix <- model_data_big %>%
  select(-orf, -log2_hlife) %>%
  sapply(., strtoi)%>%
  data.matrix()

  motifs_glm <- glmnet(motifs_matrix, y = model_data_big$log2_hlife)

#averaging MSEs of cv.glmnet and extracting lowest lambda as lambda.min
MSEs <- NULL
for (i in 1:100){
    motifs_cv_glm <- cv.glmnet(x = motifs_matrix, 
                               y = model_data_big$log2_hlife,
                               nfolds = 100)
    MSEs <- cbind(MSEs, motifs_cv_glm$cvm)
}
rownames(MSEs) <- motifs_cv_glm$lambda
lambda_min <- as.numeric(names(which.min(rowMeans(MSEs))))

coefs <- data.matrix(coef(motifs_glm, s = lambda_min))

#Create a tibble of coefficients ordered by absolute value
sig_glms <- tibble(
      motif_glmnet = rownames(coefs)[coefs != 0],
      coeff_glmnet = coefs[coefs != 0]
    ) %>%
        arrange(desc(abs(coeff_glmnet)))

sig_glms <- filter(sig_glms, motif_glmnet != "(Intercept)")
sig_motifs <- filter(sig_glms, motif_glmnet != "(Intercept)")$motif_glmnet


```



